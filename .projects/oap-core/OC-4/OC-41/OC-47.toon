id: OC-47
type: task
parent: OC-41
title: Write unit tests for Event and Disposable utilities
status: done
created: 2026-02-09
assignee: null
estimate_minutes: 35
estimate_tokens: null
blockers: ["\"ODS-1\"","\"ODS-2\"","\"\\\"ODS-1\\\"\"","\"\\\"ODS-2\\\"\"","\"\\\"\\\\\\\"ODS-1\\\\\\\"\\\"\"","\"\\\"\\\\\\\"ODS-2\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"OC-45\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"","OC-45"]
description: "**Files to create:**\n- `src/app/Services/__tests__/Disposable.test.ts`\n- `src/app/Services/__tests__/Event.test.ts`\n\n**What to do:**\n\n**Disposable.test.ts:**\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { toDisposable, combineDisposables, DisposableStore, Disposable } from '../Disposable';\n\ndescribe('Disposable utilities', () => {\n  describe('Disposable.None', () => {\n    it('should be a no-op disposable', () => {\n      expect(() => Disposable.None.dispose()).not.toThrow();\n    });\n  });\n\n  describe('toDisposable', () => {\n    it('should call the function on dispose', () => {\n      const fn = vi.fn();\n      const d = toDisposable(fn);\n      d.dispose();\n      expect(fn).toHaveBeenCalledOnce();\n    });\n\n    it('should call the function exactly once even if disposed multiple times', () => {\n      const fn = vi.fn();\n      const d = toDisposable(fn);\n      d.dispose();\n      d.dispose();\n      d.dispose();\n      expect(fn).toHaveBeenCalledOnce();\n    });\n  });\n\n  describe('combineDisposables', () => {\n    it('should dispose all in reverse order', () => {\n      const order: number[] = [];\n      const d1 = toDisposable(() => order.push(1));\n      const d2 = toDisposable(() => order.push(2));\n      const d3 = toDisposable(() => order.push(3));\n      const combined = combineDisposables(d1, d2, d3);\n      combined.dispose();\n      expect(order).toEqual([3, 2, 1]);\n    });\n\n    it('should continue disposing even if one throws', () => {\n      const errorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});\n      const d1 = toDisposable(() => { throw new Error('fail'); });\n      const d2 = toDisposable(vi.fn());\n      const combined = combineDisposables(d1, d2);\n      combined.dispose();\n      expect(errorSpy).toHaveBeenCalled();\n      errorSpy.mockRestore();\n    });\n  });\n\n  describe('DisposableStore', () => {\n    let store: DisposableStore;\n\n    beforeEach(() => {\n      store = new DisposableStore();\n    });\n\n    it('should add and dispose items', () => {\n      const fn = vi.fn();\n      store.add(toDisposable(fn));\n      expect(store.size).toBe(1);\n      store.dispose();\n      expect(fn).toHaveBeenCalledOnce();\n      expect(store.size).toBe(0);\n      expect(store.isDisposed).toBe(true);\n    });\n\n    it('should dispose in reverse order', () => {\n      const order: number[] = [];\n      store.add(toDisposable(() => order.push(1)));\n      store.add(toDisposable(() => order.push(2)));\n      store.dispose();\n      expect(order).toEqual([2, 1]);\n    });\n\n    it('should dispose immediately when adding to a disposed store', () => {\n      store.dispose();\n      const fn = vi.fn();\n      store.add(toDisposable(fn));\n      expect(fn).toHaveBeenCalledOnce();\n    });\n\n    it('should remove without disposing', () => {\n      const fn = vi.fn();\n      const d = toDisposable(fn);\n      store.add(d);\n      store.remove(d);\n      store.dispose();\n      expect(fn).not.toHaveBeenCalled();\n    });\n\n    it('should clear and stay active', () => {\n      const fn1 = vi.fn();\n      store.add(toDisposable(fn1));\n      store.clear();\n      expect(fn1).toHaveBeenCalledOnce();\n      expect(store.isDisposed).toBe(false);\n      // Can still add new items\n      const fn2 = vi.fn();\n      store.add(toDisposable(fn2));\n      store.dispose();\n      expect(fn2).toHaveBeenCalledOnce();\n    });\n  });\n});\n```\n\n**Event.test.ts:**\n```typescript\nimport { describe, it, expect, vi } from 'vitest';\nimport { Emitter, onceEvent, mapEvent, filterEvent } from '../Event';\n\ndescribe('Event system', () => {\n  describe('Emitter', () => {\n    it('should fire events to subscribers', () => {\n      const emitter = new Emitter<string>();\n      const listener = vi.fn();\n      emitter.event(listener);\n      emitter.fire('hello');\n      expect(listener).toHaveBeenCalledWith('hello');\n    });\n\n    it('should support multiple listeners', () => {\n      const emitter = new Emitter<number>();\n      const l1 = vi.fn();\n      const l2 = vi.fn();\n      emitter.event(l1);\n      emitter.event(l2);\n      emitter.fire(42);\n      expect(l1).toHaveBeenCalledWith(42);\n      expect(l2).toHaveBeenCalledWith(42);\n    });\n\n    it('should return a disposable for unsubscription', () => {\n      const emitter = new Emitter<string>();\n      const listener = vi.fn();\n      const sub = emitter.event(listener);\n      sub.dispose();\n      emitter.fire('hello');\n      expect(listener).not.toHaveBeenCalled();\n    });\n\n    it('should catch listener errors without blocking', () => {\n      const errorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});\n      const emitter = new Emitter<string>();\n      emitter.event(() => { throw new Error('boom'); });\n      const l2 = vi.fn();\n      emitter.event(l2);\n      emitter.fire('test');\n      expect(l2).toHaveBeenCalledWith('test');\n      errorSpy.mockRestore();\n    });\n\n    it('should dispose all listeners', () => {\n      const emitter = new Emitter<string>();\n      const listener = vi.fn();\n      emitter.event(listener);\n      emitter.dispose();\n      emitter.fire('hello');\n      expect(listener).not.toHaveBeenCalled();\n      expect(emitter.hasListeners).toBe(false);\n    });\n\n    it('should track hasListeners and listenerCount', () => {\n      const emitter = new Emitter<void>();\n      expect(emitter.hasListeners).toBe(false);\n      expect(emitter.listenerCount).toBe(0);\n      const sub = emitter.event(() => {});\n      expect(emitter.hasListeners).toBe(true);\n      expect(emitter.listenerCount).toBe(1);\n      sub.dispose();\n      expect(emitter.hasListeners).toBe(false);\n    });\n  });\n\n  describe('onceEvent', () => {\n    it('should fire only once then auto-unsubscribe', () => {\n      const emitter = new Emitter<string>();\n      const listener = vi.fn();\n      onceEvent(emitter.event)(listener);\n      emitter.fire('first');\n      emitter.fire('second');\n      expect(listener).toHaveBeenCalledTimes(1);\n      expect(listener).toHaveBeenCalledWith('first');\n    });\n  });\n\n  describe('mapEvent', () => {\n    it('should transform event data', () => {\n      const emitter = new Emitter<number>();\n      const mapped = mapEvent(emitter.event, (n) => n * 2);\n      const listener = vi.fn();\n      mapped(listener);\n      emitter.fire(5);\n      expect(listener).toHaveBeenCalledWith(10);\n    });\n  });\n\n  describe('filterEvent', () => {\n    it('should only deliver matching events', () => {\n      const emitter = new Emitter<number>();\n      const filtered = filterEvent(emitter.event, (n) => n > 5);\n      const listener = vi.fn();\n      filtered(listener);\n      emitter.fire(3);\n      emitter.fire(7);\n      emitter.fire(2);\n      emitter.fire(10);\n      expect(listener).toHaveBeenCalledTimes(2);\n      expect(listener).toHaveBeenCalledWith(7);\n      expect(listener).toHaveBeenCalledWith(10);\n    });\n  });\n});\n```\n\n**Verification:** Run `pnpm vitest run src/app/Services/__tests__/` and all tests pass."
acceptance_criteria[9]: Both test files exist under src/app/Services/__tests__/,All tests pass when run with vitest,"Disposable.test.ts covers: Disposable.None, toDisposable, combineDisposables, DisposableStore","Event.test.ts covers: Emitter fire/subscribe/dispose, onceEvent, mapEvent, filterEvent",Tests verify dispose-once behavior of toDisposable,Tests verify reverse-order disposal in combineDisposables and DisposableStore,Tests verify error isolation in event listeners,Tests verify DisposableStore.clear keeps store active,Each test is independent

**Dependencies:**
This task requires the following tasks to be completed first: OC-45

**⚠️ Design System Dependency:**
This task requires the Orchestra Design System foundation to be completed first (ODS-1, ODS-2). Use design tokens and core components from `packages/design-system/` instead of creating custom styles.
story: OC-41
epic: OC-4
project: oap-core
projectKey: OC
projectKey: OC
path: .projects/oap-core/OC-4/OC-41/OC-47.toon
