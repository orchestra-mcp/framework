id: OCD-95
type: task
parent: OCD-36
title: "Build API sync controller for IDE data (time entries, commits, agent)"
status: backlog
created: 2026-02-09
assignee: null
estimate_minutes: 25
estimate_tokens: null
description: "Complete the SyncController with all sync endpoints for IDE-to-cloud data synchronization.\n\n**Steps:**\n\n1. Update `src/platform/app/Http/Controllers/Api/SyncController.php` with all sync methods:\n```php\n<?php\nnamespace App\\Http\\Controllers\\Api;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Events\\AgentMessageReceived;\nuse App\\Events\\AgentStatusChanged;\nuse App\\Events\\CommitSynced;\nuse App\\Events\\TimeEntryCreated;\nuse App\\Models\\AgentMessage;\nuse App\\Models\\AgentSession;\nuse App\\Models\\CommitEntry;\nuse App\\Models\\TimeEntry;\nuse App\\Services\\TaskSyncService;\nuse Illuminate\\Http\\Request;\n\nclass SyncController extends Controller\n{\n    public function syncTasks(Request $request, TaskSyncService $syncService)\n    {\n        $request->validate([\n            'tasks' => 'required|array',\n            'tasks.*.external_id' => 'required|string',\n            'tasks.*.task_title' => 'required|string',\n            'tasks.*.project_name' => 'required|string',\n            'tasks.*.status' => 'nullable|in:backlog,in_progress,review,done',\n            'tasks.*.priority' => 'nullable|in:low,medium,high',\n        ]);\n\n        $user = $request->user();\n        $results = $syncService->syncBatch($user->id, $user->currentTeam->id, $request->tasks);\n\n        return response()->json([\n            'success' => true,\n            'synced' => count($results),\n        ]);\n    }\n\n    public function syncTimeEntries(Request $request)\n    {\n        $request->validate([\n            'entries' => 'required|array',\n            'entries.*.external_id' => 'required|string',\n            'entries.*.type' => 'required|in:timer,break,pomodoro',\n            'entries.*.started_at' => 'required|date',\n            'entries.*.ended_at' => 'nullable|date',\n            'entries.*.duration_seconds' => 'required|integer|min:0',\n            'entries.*.label' => 'nullable|string|max:255',\n        ]);\n\n        $user = $request->user();\n        $synced = 0;\n\n        foreach ($request->entries as $entryData) {\n            $entry = TimeEntry::updateOrCreate(\n                [\n                    'user_id' => $user->id,\n                    'external_id' => $entryData['external_id'],\n                ],\n                [\n                    'team_id' => $user->currentTeam->id,\n                    'type' => $entryData['type'],\n                    'label' => $entryData['label'] ?? null,\n                    'started_at' => $entryData['started_at'],\n                    'ended_at' => $entryData['ended_at'] ?? null,\n                    'duration_seconds' => $entryData['duration_seconds'],\n                ]\n            );\n\n            broadcast(new TimeEntryCreated($entry))->toOthers();\n            $synced++;\n        }\n\n        return response()->json(['success' => true, 'synced' => $synced]);\n    }\n\n    public function syncCommits(Request $request)\n    {\n        $request->validate([\n            'commits' => 'required|array',\n            'commits.*.sha' => 'required|string|size:40',\n            'commits.*.message' => 'required|string',\n            'commits.*.branch' => 'nullable|string',\n            'commits.*.repo_name' => 'required|string',\n            'commits.*.repo_provider' => 'nullable|in:github,gitlab,bitbucket',\n            'commits.*.additions' => 'nullable|integer',\n            'commits.*.deletions' => 'nullable|integer',\n            'commits.*.committed_at' => 'required|date',\n        ]);\n\n        $user = $request->user();\n        $synced = 0;\n\n        foreach ($request->commits as $commitData) {\n            $commit = CommitEntry::updateOrCreate(\n                ['sha' => $commitData['sha']],\n                [\n                    'user_id' => $user->id,\n                    'team_id' => $user->currentTeam->id,\n                    'message' => $commitData['message'],\n                    'branch' => $commitData['branch'] ?? null,\n                    'repo_name' => $commitData['repo_name'],\n                    'repo_provider' => $commitData['repo_provider'] ?? 'github',\n                    'additions' => $commitData['additions'] ?? 0,\n                    'deletions' => $commitData['deletions'] ?? 0,\n                    'committed_at' => $commitData['committed_at'],\n                ]\n            );\n\n            broadcast(new CommitSynced($commit))->toOthers();\n            $synced++;\n        }\n\n        return response()->json(['success' => true, 'synced' => $synced]);\n    }\n\n    public function syncAgentStatus(Request $request)\n    {\n        $request->validate([\n            'status' => 'required|in:idle,working,waiting_for_permission,waiting_for_answer,error',\n            'current_task' => 'nullable|string|max:500',\n        ]);\n\n        $user = $request->user();\n        $session = AgentSession::updateOrCreate(\n            ['user_id' => $user->id],\n            [\n                'status' => $request->status,\n                'current_task' => $request->current_task,\n                'started_at' => $request->status === 'working' ? now() : null,\n            ]\n        );\n\n        broadcast(new AgentStatusChanged($session));\n\n        return response()->json(['success' => true, 'session_id' => $session->id]);\n    }\n\n    public function syncAgentMessage(Request $request)\n    {\n        $request->validate([\n            'type' => 'required|in:output,prompt,permission_request,question,error',\n            'content' => 'required|string',\n            'metadata' => 'nullable|array',\n        ]);\n\n        $user = $request->user();\n        $session = AgentSession::where('user_id', $user->id)->latest()->first();\n\n        if (!$session) {\n            $session = AgentSession::create(['user_id' => $user->id, 'status' => 'working']);\n        }\n\n        // Update session status based on message type\n        if ($request->type === 'permission_request') {\n            $session->update(['status' => 'waiting_for_permission']);\n        } elseif ($request->type === 'question') {\n            $session->update(['status' => 'waiting_for_answer']);\n        }\n\n        $message = AgentMessage::create([\n            'agent_session_id' => $session->id,\n            'user_id' => $user->id,\n            'type' => $request->type,\n            'sender' => 'agent',\n            'content' => $request->content,\n            'metadata' => $request->metadata,\n        ]);\n\n        broadcast(new AgentMessageReceived($message));\n\n        return response()->json(['success' => true, 'message_id' => $message->id]);\n    }\n}\n```\n\n2. Run `php artisan route:list --path=api/v1/sync` to verify sync routes.\n\n**File paths:**\n- `src/platform/app/Http/Controllers/Api/SyncController.php` (complete)"
acceptance_criteria[10]: "POST /api/v1/sync/tasks accepts array of tasks, validates, and syncs via TaskSyncService","POST /api/v1/sync/time-entries upserts by external_id, broadcasts TimeEntryCreated","POST /api/v1/sync/commits upserts by SHA, broadcasts CommitSynced","POST /api/v1/sync/agent-status updates session status, broadcasts AgentStatusChanged","POST /api/v1/sync/agent-message creates message, updates session status for permission/question types","All sync endpoints return { success: true, synced: count }",All sync endpoints validate input data,All sync endpoints broadcast events for real-time updates,"Idempotent: same data can be synced multiple times safely",Agent session auto-created if none exists
story: OCD-36
epic: OCD-8
project: oap-cloud
projectKey: OCD
path: .projects/oap-cloud/OCD-8/OCD-36/OCD-95.toon
