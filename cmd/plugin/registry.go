package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// registryEntry holds the data needed to generate one plugin import + call.
type registryEntry struct {
	Alias       string // import alias (e.g. "mcpproviders")
	ImportPath  string // full import path (e.g. "github.com/orchestra-mcp/mcp/providers")
	Constructor string // constructor name (e.g. "NewMcpPlugin")
}

// cmdRegistry generates config/plugins_registry.go from discovered plugins.
func cmdRegistry(args []string) {
	fs := flag.NewFlagSet("registry", flag.ExitOnError)
	pathFlag := fs.String("path", "plugins", "Plugins directory")
	outFlag := fs.String("out", "config/registry/plugins.go", "Output file path")
	fs.Parse(args)

	entries, err := discoverPlugins(*pathFlag)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %s\n", err)
		os.Exit(1)
	}

	if len(entries) == 0 {
		fmt.Fprintln(os.Stderr, "No plugins discovered.")
		os.Exit(1)
	}

	if err := writeRegistryFile(*outFlag, entries); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing registry: %s\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d plugin(s)\n", *outFlag, len(entries))
}

// discoverPlugins scans pluginsDir for valid plugin providers.
func discoverPlugins(pluginsDir string) ([]registryEntry, error) {
	entries, err := os.ReadDir(pluginsDir)
	if err != nil {
		return nil, fmt.Errorf("read plugins dir %s: %w", pluginsDir, err)
	}

	var result []registryEntry
	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		re, err := parsePluginEntry(pluginsDir, entry.Name())
		if err != nil {
			continue // skip plugins that cannot be parsed
		}
		result = append(result, *re)
	}
	return result, nil
}

// parsePluginEntry extracts module path and constructor from one plugin.
func parsePluginEntry(pluginsDir, dirName string) (*registryEntry, error) {
	modulePath, err := readModulePath(filepath.Join(pluginsDir, dirName, "go.mod"))
	if err != nil {
		return nil, err
	}

	providerPath := filepath.Join(pluginsDir, dirName, "providers", "plugin.go")
	constructor, err := readConstructor(providerPath)
	if err != nil {
		return nil, err
	}

	alias := dirName + "providers"
	importPath := modulePath + "/providers"

	return &registryEntry{
		Alias:       alias,
		ImportPath:  importPath,
		Constructor: constructor,
	}, nil
}

// readModulePath extracts the module name from a go.mod file.
func readModulePath(goModPath string) (string, error) {
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return "", fmt.Errorf("read go.mod: %w", err)
	}
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module ")), nil
		}
	}
	return "", fmt.Errorf("no module directive in %s", goModPath)
}

// constructorPattern matches `func NewXxxPlugin()` in provider source.
var constructorPattern = regexp.MustCompile(`func (New\w+Plugin)\(\)`)

// readConstructor extracts the NewXxxPlugin constructor name from provider source.
func readConstructor(providerPath string) (string, error) {
	data, err := os.ReadFile(providerPath)
	if err != nil {
		return "", fmt.Errorf("read provider: %w", err)
	}
	matches := constructorPattern.FindSubmatch(data)
	if len(matches) < 2 {
		return "", fmt.Errorf("no constructor found in %s", providerPath)
	}
	return string(matches[1]), nil
}

// writeRegistryFile generates the Go source for the plugin registry.
func writeRegistryFile(outPath string, entries []registryEntry) error {
	var b strings.Builder

	b.WriteString("// Code generated by orchestra-plugin registry; DO NOT EDIT.\n\n")
	b.WriteString("package registry\n\n")

	// Imports block.
	b.WriteString("import (\n")
	b.WriteString("\t\"github.com/orchestra-mcp/framework/app/plugins\"\n")
	for _, e := range entries {
		fmt.Fprintf(&b, "\t%s %q\n", e.Alias, e.ImportPath)
	}
	b.WriteString(")\n\n")

	// Function body.
	b.WriteString("// AllPlugins returns all auto-discovered plugin instances.\n")
	b.WriteString("// Import this ONLY from cmd/server/main.go to avoid import cycles.\n")
	b.WriteString("func AllPlugins() []plugins.Plugin {\n")
	b.WriteString("\treturn []plugins.Plugin{\n")
	for _, e := range entries {
		fmt.Fprintf(&b, "\t\t%s.%s(),\n", e.Alias, e.Constructor)
	}
	b.WriteString("\t}\n")
	b.WriteString("}\n")

	if err := os.MkdirAll(filepath.Dir(outPath), 0755); err != nil {
		return fmt.Errorf("create output dir: %w", err)
	}
	return os.WriteFile(outPath, []byte(b.String()), 0644)
}
