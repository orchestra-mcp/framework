id: OC-46
type: task
parent: OC-41
title: Create typed Event and EventEmitter utilities
status: done
created: 2026-02-09
assignee: null
estimate_minutes: 30
estimate_tokens: null
blockers: ["\"ODS-1\"","\"ODS-2\"","\"\\\"ODS-1\\\"\"","\"\\\"ODS-2\\\"\"","\"\\\"\\\\\\\"ODS-1\\\\\\\"\\\"\"","\"\\\"\\\\\\\"ODS-2\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"OC-45\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"","OC-45"]
description: "**File to create:** `src/app/Services/Event.ts`\n\n**What to do:**\n1. Create `src/app/Services/Event.ts` with a typed event system that returns Disposables for all subscriptions:\n\n```typescript\nimport type { IDisposable } from './Disposable';\nimport { toDisposable } from './Disposable';\n\n// ─── Event Type ─────────────────────────────────────────────────────\n\n/**\n * A typed event that can be subscribed to.\n * Subscribing returns a Disposable for unsubscription.\n *\n * @example\n * ```typescript\n * interface MyService {\n *   readonly onDidChange: Event<string>;\n * }\n *\n * // Subscribe\n * const disposable = myService.onDidChange((value) => {\n *   console.log('Changed:', value);\n * });\n *\n * // Unsubscribe\n * disposable.dispose();\n * ```\n */\nexport type Event<T> = (listener: (e: T) => void) => IDisposable;\n\n// ─── EventEmitter ───────────────────────────────────────────────────\n\n/**\n * Typed event emitter that produces Event<T> instances.\n * \n * Use this in services to expose typed events.\n *\n * @example\n * ```typescript\n * class MyService {\n *   private readonly _onDidChange = new Emitter<string>();\n *   readonly onDidChange: Event<string> = this._onDidChange.event;\n *\n *   doSomething() {\n *     this._onDidChange.fire('something changed');\n *   }\n *\n *   dispose() {\n *     this._onDidChange.dispose();\n *   }\n * }\n * ```\n */\nexport class Emitter<T> implements IDisposable {\n  private listeners: Array<(e: T) => void> = [];\n  private _disposed = false;\n\n  /**\n   * The event that consumers subscribe to.\n   * Returns a Disposable for unsubscription.\n   */\n  readonly event: Event<T> = (listener: (e: T) => void): IDisposable => {\n    if (this._disposed) {\n      console.warn('[Emitter] Subscribing to a disposed emitter');\n      return toDisposable(() => {});\n    }\n\n    this.listeners.push(listener);\n\n    return toDisposable(() => {\n      const idx = this.listeners.indexOf(listener);\n      if (idx >= 0) {\n        this.listeners.splice(idx, 1);\n      }\n    });\n  };\n\n  /**\n   * Fire the event, notifying all listeners with the given data.\n   * Listener errors are caught and logged.\n   */\n  fire(data: T): void {\n    if (this._disposed) return;\n\n    // Copy listeners array to allow modifications during iteration\n    const listeners = [...this.listeners];\n    for (const listener of listeners) {\n      try {\n        listener(data);\n      } catch (err) {\n        console.error('[Emitter] Error in event listener:', err);\n      }\n    }\n  }\n\n  /**\n   * Check if there are any listeners.\n   */\n  get hasListeners(): boolean {\n    return this.listeners.length > 0;\n  }\n\n  /**\n   * Number of active listeners.\n   */\n  get listenerCount(): number {\n    return this.listeners.length;\n  }\n\n  /**\n   * Dispose the emitter and remove all listeners.\n   */\n  dispose(): void {\n    if (this._disposed) return;\n    this._disposed = true;\n    this.listeners.length = 0;\n  }\n}\n\n// ─── Event Utilities ────────────────────────────────────────────────\n\n/**\n * Create an Event that fires only once, then auto-disposes.\n */\nexport function onceEvent<T>(event: Event<T>): Event<T> {\n  return (listener: (e: T) => void): IDisposable => {\n    let didFire = false;\n    const result = event((e) => {\n      if (didFire) return;\n      didFire = true;\n      result.dispose();\n      listener(e);\n    });\n    return result;\n  };\n}\n\n/**\n * Create an Event that maps/transforms the event data.\n */\nexport function mapEvent<T, U>(event: Event<T>, map: (value: T) => U): Event<U> {\n  return (listener: (e: U) => void): IDisposable => {\n    return event((e) => listener(map(e)));\n  };\n}\n\n/**\n * Create an Event that filters event data.\n */\nexport function filterEvent<T>(event: Event<T>, filter: (value: T) => boolean): Event<T> {\n  return (listener: (e: T) => void): IDisposable => {\n    return event((e) => {\n      if (filter(e)) listener(e);\n    });\n  };\n}\n```\n\n2. **Add to `src/app/Services/index.ts`:**\n```typescript\nexport { Emitter, onceEvent, mapEvent, filterEvent } from './Event';\nexport type { Event } from './Event';\n```\n\n**Verification:** `pnpm typecheck` passes. The Event system is fully typed and returns Disposables."
acceptance_criteria[13]: src/app/Services/Event.ts exists with all implementations,Event<T> type is a function that takes a listener and returns IDisposable,Emitter<T> class fires events to all subscribers with typed payload,Emitter.event property is the subscribable Event<T>,Emitter.fire() catches and logs listener errors without blocking other listeners,Emitter.dispose() removes all listeners and prevents future subscriptions,Subscribing to a disposed emitter logs warning and returns no-op disposable,onceEvent creates an event that fires only once then auto-unsubscribes,mapEvent transforms event data before delivering to listener,filterEvent only delivers events that pass the predicate,Emitter.hasListeners and listenerCount properties work,All exported from src/app/Services/index.ts,File passes pnpm typecheck

**Dependencies:**
This task requires the following tasks to be completed first: OC-45

**⚠️ Design System Dependency:**
This task requires the Orchestra Design System foundation to be completed first (ODS-1, ODS-2). Use design tokens and core components from `packages/design-system/` instead of creating custom styles.
story: OC-41
epic: OC-4
project: oap-core
projectKey: OC
projectKey: OC
path: .projects/oap-core/OC-4/OC-41/OC-46.toon
