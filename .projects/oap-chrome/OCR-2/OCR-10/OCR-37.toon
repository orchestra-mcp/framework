id: OCR-37
type: task
parent: OCR-10
title: Create tabStore Zustand store for tab state management
status: done
created: 2026-02-09
assignee: null
estimate_minutes: 40
estimate_tokens: null
blockers: ["\"ODS-1\"","\"ODS-2\"","\"\\\"ODS-1\\\"\"","\"\\\"ODS-2\\\"\"","\"\\\"\\\\\\\"ODS-1\\\\\\\"\\\"\"","\"\\\"\\\\\\\"ODS-2\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"OCR-36\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"","OCR-36"]
description: "Create the Zustand store that manages all tab state including open tabs, active tabs per split group, tab registrations, and split view configuration.\n\n**Target file:** `src/app/Chrome/Tabs/tabStore.ts`\n\n**Implementation:**\n\n```typescript\nimport { create } from 'zustand';\nimport type { TabRegistration, TabInstance, SplitState } from './types';\n\ninterface TabStoreState {\n  /** Registered tab types (map of type id -> registration) */\n  registrations: Map<string, TabRegistration>;\n  /** All open tab instances */\n  tabs: TabInstance[];\n  /** Active tab id per split group. Key = split group index (0 or 1) */\n  activeTabIds: Record<number, string | null>;\n  /** Split view state */\n  split: SplitState;\n\n  // Actions\n  registerTabType: (registration: TabRegistration) => void;\n  unregisterTabType: (id: string) => void;\n  openTab: (type: string, options?: { label?: string; data?: unknown; splitGroup?: number }) => string;\n  closeTab: (tabId: string) => void;\n  focusTab: (tabId: string) => void;\n  closeOthers: (tabId: string) => void;\n  closeAll: (splitGroup?: number) => void;\n  reorderTabs: (fromIndex: number, toIndex: number, splitGroup: number) => void;\n  splitTab: (tabId: string, direction: 'horizontal' | 'vertical') => void;\n  setSplitRatio: (ratio: number) => void;\n  closeSplit: () => void;\n  setDirty: (tabId: string, dirty: boolean) => void;\n}\n\nfunction generateTabId(): string {\n  return `tab-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;\n}\n\nexport const useTabStore = create<TabStoreState>((set, get) => ({\n  registrations: new Map(),\n  tabs: [],\n  activeTabIds: { 0: null, 1: null },\n  split: { enabled: false, direction: 'horizontal', ratio: 0.5 },\n\n  registerTabType: (registration) => {\n    set((state) => {\n      const registrations = new Map(state.registrations);\n      registrations.set(registration.id, registration);\n      return { registrations };\n    });\n  },\n\n  unregisterTabType: (id) => {\n    set((state) => {\n      const registrations = new Map(state.registrations);\n      registrations.delete(id);\n      return { registrations };\n    });\n  },\n\n  openTab: (type, options) => {\n    const reg = get().registrations.get(type);\n    const tabId = generateTabId();\n    const splitGroup = options?.splitGroup ?? 0;\n\n    const instance: TabInstance = {\n      id: tabId,\n      type,\n      label: options?.label ?? reg?.label ?? type,\n      icon: reg?.icon,\n      closable: reg?.closable ?? true,\n      data: options?.data,\n      splitGroup,\n      dirty: false,\n    };\n\n    set((state) => {\n      const tabs = [...state.tabs, instance];\n      const activeTabIds = { ...state.activeTabIds, [splitGroup]: tabId };\n      return { tabs, activeTabIds };\n    });\n\n    return tabId;\n  },\n\n  closeTab: (tabId) => {\n    set((state) => {\n      const tab = state.tabs.find((t) => t.id === tabId);\n      if (!tab) return state;\n\n      const tabs = state.tabs.filter((t) => t.id !== tabId);\n      const activeTabIds = { ...state.activeTabIds };\n\n      // If closing the active tab, activate the nearest neighbor in same split group\n      if (activeTabIds[tab.splitGroup] === tabId) {\n        const groupTabs = tabs.filter((t) => t.splitGroup === tab.splitGroup);\n        activeTabIds[tab.splitGroup] = groupTabs.length > 0\n          ? groupTabs[groupTabs.length - 1].id\n          : null;\n      }\n\n      // If split group 1 is now empty, close the split\n      const split = tab.splitGroup === 1 && tabs.filter((t) => t.splitGroup === 1).length === 0\n        ? { ...state.split, enabled: false }\n        : state.split;\n\n      return { tabs, activeTabIds, split };\n    });\n  },\n\n  focusTab: (tabId) => {\n    const tab = get().tabs.find((t) => t.id === tabId);\n    if (!tab) return;\n    set((state) => ({\n      activeTabIds: { ...state.activeTabIds, [tab.splitGroup]: tabId },\n    }));\n  },\n\n  closeOthers: (tabId) => {\n    set((state) => {\n      const tab = state.tabs.find((t) => t.id === tabId);\n      if (!tab) return state;\n      const tabs = state.tabs.filter((t) => t.id === tabId || !t.closable);\n      return { tabs, activeTabIds: { ...state.activeTabIds, [tab.splitGroup]: tabId } };\n    });\n  },\n\n  closeAll: (splitGroup) => {\n    set((state) => {\n      const tabs = splitGroup !== undefined\n        ? state.tabs.filter((t) => t.splitGroup !== splitGroup || !t.closable)\n        : state.tabs.filter((t) => !t.closable);\n      const activeTabIds = { ...state.activeTabIds };\n      if (splitGroup !== undefined) {\n        const remaining = tabs.filter((t) => t.splitGroup === splitGroup);\n        activeTabIds[splitGroup] = remaining[0]?.id ?? null;\n      } else {\n        activeTabIds[0] = tabs.filter((t) => t.splitGroup === 0)[0]?.id ?? null;\n        activeTabIds[1] = tabs.filter((t) => t.splitGroup === 1)[0]?.id ?? null;\n      }\n      return { tabs, activeTabIds };\n    });\n  },\n\n  reorderTabs: (fromIndex, toIndex, splitGroup) => {\n    set((state) => {\n      const groupTabs = state.tabs.filter((t) => t.splitGroup === splitGroup);\n      const otherTabs = state.tabs.filter((t) => t.splitGroup !== splitGroup);\n      const [moved] = groupTabs.splice(fromIndex, 1);\n      groupTabs.splice(toIndex, 0, moved);\n      return { tabs: [...otherTabs, ...groupTabs] };\n    });\n  },\n\n  splitTab: (tabId, direction) => {\n    set((state) => {\n      const tab = state.tabs.find((t) => t.id === tabId);\n      if (!tab) return state;\n      const tabs = state.tabs.map((t) =>\n        t.id === tabId ? { ...t, splitGroup: 1 } : t\n      );\n      return {\n        tabs,\n        split: { enabled: true, direction, ratio: 0.5 },\n        activeTabIds: { ...state.activeTabIds, 1: tabId },\n      };\n    });\n  },\n\n  setSplitRatio: (ratio) => {\n    set((state) => ({ split: { ...state.split, ratio: Math.max(0.2, Math.min(0.8, ratio)) } }));\n  },\n\n  closeSplit: () => {\n    set((state) => {\n      // Move all split group 1 tabs back to group 0\n      const tabs = state.tabs.map((t) => t.splitGroup === 1 ? { ...t, splitGroup: 0 } : t);\n      return {\n        tabs,\n        split: { enabled: false, direction: 'horizontal', ratio: 0.5 },\n        activeTabIds: { 0: state.activeTabIds[0], 1: null },\n      };\n    });\n  },\n\n  setDirty: (tabId, dirty) => {\n    set((state) => ({\n      tabs: state.tabs.map((t) => t.id === tabId ? { ...t, dirty } : t),\n    }));\n  },\n}));\n```\n\nUpdate barrel export in `src/app/Chrome/Tabs/index.ts` to include:\n```typescript\nexport { useTabStore } from './tabStore';\n```"
acceptance_criteria[11]: File src/app/Chrome/Tabs/tabStore.ts exists with useTabStore,"Store manages registrations, tabs, activeTabIds, split state",openTab creates TabInstance with generated id and returns it,closeTab removes tab and activates nearest neighbor,focusTab sets active tab for the correct split group,reorderTabs moves tab within a split group,splitTab moves a tab to split group 1 and enables split,closeSplit moves all group 1 tabs back to group 0,setDirty updates dirty flag on specific tab,closeAll respects closable flag (non-closable tabs survive),Barrel export updated

**Dependencies:**
This task requires the following tasks to be completed first: OCR-36

**⚠️ Design System Dependency:**
This task requires the Orchestra Design System foundation to be completed first (ODS-1, ODS-2). Use design tokens and core components from `packages/design-system/` instead of creating custom styles.
story: OCR-10
epic: OCR-2
project: oap-chrome
projectKey: OCR
projectKey: OCR
path: .projects/oap-chrome/OCR-2/OCR-10/OCR-37.toon
