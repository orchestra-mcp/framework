id: OC-19
type: task
parent: OC-15
title: Create ServiceRegistry.ts with DI container and createServiceId
status: done
created: 2026-02-09
assignee: null
estimate_minutes: 30
estimate_tokens: null
blockers: ["\"\\\"ODS-1\\\"\"","\"\\\"ODS-2\\\"\"","\"ODS-1\"","\"ODS-2\"","ODS-1","ODS-2"]
description: "**File to create:** `src/app/Providers/ServiceRegistry.ts`\n\n**Reference file to copy from:** `packages/desktop/src/main/platform/serviceRegistry.ts`\n**Reference types:** `packages/desktop/src/main/platform/types/services.ts`\n\n**What to do:**\n1. Create the directory `src/app/Providers/` if it doesn't exist\n2. Create `src/app/Providers/ServiceRegistry.ts`\n3. Copy the structure from the reference file but enhance it with these additions:\n\n**a) Copy the type definitions inline (don't import from old location):**\n```typescript\nexport interface ServiceIdentifier<T> {\n  readonly _serviceId: string;\n  readonly _brand: T;\n}\n\nexport type ServiceScope = 'application' | 'workspace' | 'editor';\n\nexport interface ServiceDescriptor<T> {\n  readonly id: ServiceIdentifier<T>;\n  readonly scope: ServiceScope;\n  readonly factory: () => T;\n  readonly dependencies?: ServiceIdentifier<unknown>[];\n}\n```\n\n**b) Copy the `createServiceId<T>()` function exactly as-is from reference:**\n```typescript\nconst _serviceIds = new Map<string, ServiceIdentifier<unknown>>();\n\nexport function createServiceId<T>(serviceId: string): ServiceIdentifier<T> {\n  if (_serviceIds.has(serviceId)) {\n    return _serviceIds.get(serviceId) as ServiceIdentifier<T>;\n  }\n  const id: ServiceIdentifier<T> = {\n    _serviceId: serviceId,\n    _brand: undefined as unknown as T,\n  };\n  _serviceIds.set(serviceId, id);\n  return id;\n}\n```\n\n**c) Copy the ServiceRegistry class from reference but ADD these new features:**\n\n1. **`resolve()` method** — alias for `get()` for more standard DI naming:\n```typescript\nresolve<T>(id: ServiceIdentifier<T>, scopeId?: string): T {\n  return this.get(id, scopeId);\n}\n```\n\n2. **`dispose()` method** — clears all registrations and calls dispose on any services that implement IDisposable:\n```typescript\ndispose(): void {\n  // Dispose all services that have a dispose method\n  for (const [, service] of this._applicationServices) {\n    if (service && typeof (service as any).dispose === 'function') {\n      try { (service as any).dispose(); } catch (e) { console.warn('[ServiceRegistry] dispose error:', e); }\n    }\n  }\n  this._applicationServices.clear();\n  this._workspaceServices.clear();\n  this._editorServices.clear();\n  this._descriptors.clear();\n}\n```\n\n3. **Circular dependency detection** — When resolving a descriptor (lazy factory), track what's currently being resolved and throw if a cycle is detected:\n```typescript\nprivate _resolving = new Set<string>();\n\nresolveDescriptor<T>(id: ServiceIdentifier<T>): T {\n  if (this._resolving.has(id._serviceId)) {\n    throw new Error(`Circular dependency detected: ${[...this._resolving, id._serviceId].join(' -> ')}`);\n  }\n  const descriptor = this._descriptors.get(id._serviceId) as ServiceDescriptor<T> | undefined;\n  if (!descriptor) {\n    throw new Error(`No descriptor registered for: ${id._serviceId}`);\n  }\n  this._resolving.add(id._serviceId);\n  try {\n    const instance = descriptor.factory();\n    this.register(id, descriptor.scope, instance);\n    return instance;\n  } finally {\n    this._resolving.delete(id._serviceId);\n  }\n}\n```\n\n**d) Keep the global singleton pattern:**\n```typescript\nlet _globalRegistry: ServiceRegistry | null = null;\n\nexport function getServiceRegistry(): ServiceRegistry {\n  if (!_globalRegistry) {\n    _globalRegistry = new ServiceRegistry();\n  }\n  return _globalRegistry;\n}\n\nexport function resetServiceRegistry(): void {\n  _globalRegistry?.dispose();\n  _globalRegistry = null;\n}\n```\n\n**e) Export everything from an index file:**\nCreate `src/app/Providers/index.ts`:\n```typescript\nexport { ServiceRegistry, createServiceId, getServiceRegistry, resetServiceRegistry } from './ServiceRegistry';\nexport type { ServiceIdentifier, ServiceScope, ServiceDescriptor } from './ServiceRegistry';\n```\n\n**Verification:** The file compiles with `pnpm typecheck`. All exports are accessible from the index."
acceptance_criteria[9]: src/app/Providers/ServiceRegistry.ts exists and exports ServiceRegistry class,createServiceId<T>() is exported and produces typed identifiers,"register() supports application, workspace, and editor scopes",resolve() is an alias for get() with scope fallback chain,dispose() clears all services and calls dispose on IDisposable services,Circular dependency detection throws Error with dependency chain in message,resolveDescriptor() lazy-instantiates from factory and caches result,src/app/Providers/index.ts re-exports all public APIs,File passes pnpm typecheck

**IMPORTANT:** Before starting, use the Read tool to read `packages/desktop/src/main/platform/serviceRegistry.ts` to understand the structure and implementation patterns.

**⚠️ Design System Dependency:**
This task requires the Orchestra Design System foundation to be completed first (ODS-1, ODS-2). Use design tokens and core components from `packages/design-system/` instead of creating custom styles.

**IMPORTANT:** Before starting, use the Read tool to read `packages/desktop/src/main/platform/serviceRegistry.ts` to understand the structure and implementation patterns.
story: OC-15
epic: OC-2
project: oap-core
projectKey: OC
projectKey: OC
path: .projects/oap-core/OC-2/OC-15/OC-19.toon
