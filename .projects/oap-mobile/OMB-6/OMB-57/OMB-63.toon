id: OMB-63
type: task
parent: OMB-57
title: "Build offline support with cache, action queue, and sync"
status: backlog
created: 2026-02-09
assignee: null
estimate_minutes: 55
estimate_tokens: null
blockers: []
description: "Implement offline support: local caching, action queue for offline mutations, and reconnect sync.\n\n1. Install NetInfo for network status monitoring:\n   ```bash\n   cd src/mobile\n   npm install @react-native-community/netinfo\n   ```\n   For iOS: `cd ios && pod install`\n\n2. Create `src/mobile/src/services/offlineCache.ts`:\n   ```typescript\n   import AsyncStorage from '@react-native-async-storage/async-storage';\n\n   const CACHE_PREFIX = '@orchestra_cache:';\n   const CACHE_TTL = 30 * 60 * 1000; // 30 minutes\n\n   interface CachedData<T> {\n     data: T;\n     timestamp: number;\n   }\n\n   export const offlineCache = {\n     async set<T>(key: string, data: T): Promise<void> {\n       const cached: CachedData<T> = { data, timestamp: Date.now() };\n       await AsyncStorage.setItem(`${CACHE_PREFIX}${key}`, JSON.stringify(cached));\n     },\n\n     async get<T>(key: string): Promise<T | null> {\n       try {\n         const raw = await AsyncStorage.getItem(`${CACHE_PREFIX}${key}`);\n         if (!raw) return null;\n         const cached: CachedData<T> = JSON.parse(raw);\n         // Check TTL\n         if (Date.now() - cached.timestamp > CACHE_TTL) {\n           await AsyncStorage.removeItem(`${CACHE_PREFIX}${key}`);\n           return null;\n         }\n         return cached.data;\n       } catch {\n         return null;\n       }\n     },\n\n     async remove(key: string): Promise<void> {\n       await AsyncStorage.removeItem(`${CACHE_PREFIX}${key}`);\n     },\n\n     async clearAll(): Promise<void> {\n       const keys = await AsyncStorage.getAllKeys();\n       const cacheKeys = keys.filter((k) => k.startsWith(CACHE_PREFIX));\n       await AsyncStorage.multiRemove(cacheKeys);\n     },\n   };\n   ```\n\n3. Create `src/mobile/src/services/offlineQueue.ts`:\n   ```typescript\n   import AsyncStorage from '@react-native-async-storage/async-storage';\n   import { apiClient } from './apiClient';\n\n   const QUEUE_KEY = '@orchestra_offline_queue';\n\n   interface QueuedAction {\n     id: string;\n     method: 'post' | 'patch' | 'put' | 'delete';\n     url: string;\n     data?: Record<string, unknown>;\n     timestamp: number;\n   }\n\n   export const offlineQueue = {\n     async enqueue(action: Omit<QueuedAction, 'id' | 'timestamp'>): Promise<void> {\n       const queue = await this.getQueue();\n       queue.push({\n         ...action,\n         id: `action-${Date.now()}-${Math.random().toString(36).slice(2)}`,\n         timestamp: Date.now(),\n       });\n       await AsyncStorage.setItem(QUEUE_KEY, JSON.stringify(queue));\n     },\n\n     async getQueue(): Promise<QueuedAction[]> {\n       try {\n         const raw = await AsyncStorage.getItem(QUEUE_KEY);\n         return raw ? JSON.parse(raw) : [];\n       } catch {\n         return [];\n       }\n     },\n\n     async processQueue(): Promise<{ succeeded: number; failed: number }> {\n       const queue = await this.getQueue();\n       if (queue.length === 0) return { succeeded: 0, failed: 0 };\n\n       let succeeded = 0;\n       let failed = 0;\n       const remainingActions: QueuedAction[] = [];\n\n       for (const action of queue) {\n         try {\n           await apiClient.request({\n             method: action.method,\n             url: action.url,\n             data: action.data,\n           });\n           succeeded++;\n         } catch (error: any) {\n           if (error.response?.status === 409) {\n             // Conflict - discard action (server state wins)\n             console.warn(`[OfflineQueue] Conflict for action ${action.id}, discarding`);\n             succeeded++; // Count as \"processed\"\n           } else if (error.response?.status && error.response.status >= 400 && error.response.status < 500) {\n             // Client error - discard (retrying won't help)\n             console.warn(`[OfflineQueue] Client error ${error.response.status} for action ${action.id}, discarding`);\n             failed++;\n           } else {\n             // Server/network error - keep in queue for retry\n             remainingActions.push(action);\n             failed++;\n           }\n         }\n       }\n\n       await AsyncStorage.setItem(QUEUE_KEY, JSON.stringify(remainingActions));\n       return { succeeded, failed };\n     },\n\n     async clear(): Promise<void> {\n       await AsyncStorage.removeItem(QUEUE_KEY);\n     },\n\n     async count(): Promise<number> {\n       const queue = await this.getQueue();\n       return queue.length;\n     },\n   };\n   ```\n\n4. Create `src/mobile/src/services/networkMonitor.ts`:\n   ```typescript\n   import NetInfo, { NetInfoState } from '@react-native-community/netinfo';\n   import { useAppStore } from '@stores';\n   import { offlineQueue } from './offlineQueue';\n   import { socketService } from './socketService';\n\n   class NetworkMonitor {\n     private unsubscribe: (() => void) | null = null;\n\n     start(): void {\n       this.unsubscribe = NetInfo.addEventListener((state: NetInfoState) => {\n         const wasOnline = useAppStore.getState().isOnline;\n         const isNowOnline = state.isConnected === true && state.isInternetReachable !== false;\n\n         useAppStore.getState().setOnline(isNowOnline);\n\n         // Reconnected! Process offline queue and reconnect socket\n         if (!wasOnline && isNowOnline) {\n           console.log('[Network] Back online, processing offline queue');\n           offlineQueue.processQueue().then((result) => {\n             console.log(`[Network] Queue processed: ${result.succeeded} succeeded, ${result.failed} failed`);\n           });\n\n           // Reconnect WebSocket if authenticated\n           if (!socketService.isConnected) {\n             socketService.connect();\n           }\n         }\n       });\n     }\n\n     stop(): void {\n       this.unsubscribe?.();\n       this.unsubscribe = null;\n     }\n   }\n\n   export const networkMonitor = new NetworkMonitor();\n   ```\n\n5. Create `src/mobile/src/components/common/OfflineBanner.tsx`:\n   ```typescript\n   import React from 'react';\n   import { View, Text, Animated } from 'react-native';\n   import Icon from 'react-native-vector-icons/Ionicons';\n   import { useAppStore } from '@stores';\n\n   export const OfflineBanner: React.FC = () => {\n     const isOnline = useAppStore((s) => s.isOnline);\n\n     if (isOnline) return null;\n\n     return (\n       <View className=\"bg-amber-500 py-2 px-4 flex-row items-center justify-center\">\n         <Icon name=\"cloud-offline-outline\" size={16} color=\"#ffffff\" />\n         <Text className=\"text-white text-xs font-semibold ml-2\">\n           You're offline. Changes will sync when reconnected.\n         </Text>\n       </View>\n     );\n   };\n   ```\n\n6. Add OfflineBanner to App.tsx below StatusBar:\n   ```typescript\n   import { OfflineBanner } from '@components/common/OfflineBanner';\n\n   // In render, after StatusBar:\n   <OfflineBanner />\n   ```\n\n7. Initialize networkMonitor in App.tsx:\n   ```typescript\n   import { networkMonitor } from '@services/networkMonitor';\n\n   useEffect(() => {\n     networkMonitor.start();\n     return () => networkMonitor.stop();\n   }, []);\n   ```\n\n8. Update the apiClient request interceptor to use offlineQueue when offline:\n   ```typescript\n   // In apiClient.ts, add to request interceptor:\n   import { useAppStore } from '@stores';\n   import { offlineQueue } from './offlineQueue';\n\n   // Before the existing request interceptor, add:\n   apiClient.interceptors.request.use(\n     async (requestConfig) => {\n       const isOnline = useAppStore.getState().isOnline;\n       if (!isOnline && requestConfig.method !== 'get') {\n         // Queue the mutation for later\n         await offlineQueue.enqueue({\n           method: requestConfig.method as any,\n           url: requestConfig.url ?? '',\n           data: requestConfig.data,\n         });\n         // Reject with a special error so caller knows it was queued\n         return Promise.reject({ __offline_queued: true, message: 'Action queued for offline sync' });\n       }\n       return requestConfig;\n     },\n   );\n   ```\n\n9. Export all from services/index.ts and components/common/index.ts.\n\n10. Verify: Offline banner appears when network disconnects. Mutations are queued when offline. Queue processes when network reconnects. Socket reconnects on network restore."
acceptance_criteria[11]: @react-native-community/netinfo installed,offlineCache.ts provides set/get/remove/clearAll with 30-minute TTL,"offlineQueue.ts queues mutations with enqueue(), replays with processQueue()","processQueue handles 409 conflicts by discarding, 4xx errors by discarding, 5xx/network by retrying",networkMonitor.ts listens to NetInfo and updates appStore.isOnline,"When coming back online: processes offline queue and reconnects WebSocket",OfflineBanner.tsx shows amber banner with cloud-offline icon when offline,OfflineBanner hidden when online,App.tsx includes OfflineBanner and initializes networkMonitor,apiClient interceptor queues non-GET requests when offline instead of sending,offlineQueue.count() returns pending action count for UI display

**⚠️ Design System Dependency:**
This task requires the Orchestra Design System foundation to be completed first (ODS-1, ODS-2). Use design tokens and core components from `packages/design-system/` instead of creating custom styles.
story: OMB-57
epic: OMB-6
project: oap-mobile
projectKey: OMB
path: .projects/oap-mobile/OMB-6/OMB-57/OMB-63.toon
